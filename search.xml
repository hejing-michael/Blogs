<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Gradle之FTP文件下载]]></title>
    <url>%2F2019%2F09%2F10%2FGradle%E4%B9%8BFTP%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Gradle之FTP文件下载1、背景项目上需要使用本地web，所以我们直接将web直接放入assets资源文件夹下。但是随着开发进行web包越来越大；所以我们想着从版本库里面去掉web将其忽略掉，使用gradle命令下载web。由于web包是放在局域网服务器上的，服务器支持FTP文件协议，所以使用FTP插件下载文件。 2、FTPFTP官网文档Gradle官网文档gradle配置 3、FTP工具ftp-util.gradle 123456789101112131415161718192021222324252627282930313233configurations &#123; ftpAntTask&#125;dependencies &#123; ftpAntTask(&quot;org.apache.ant:ant-commons-net:1.9.2&quot;) &#123; module(&quot;commons-net:commons-net:3.3&quot;) &#125;&#125;void downloadFtpFiles(String serverIp, String userId, String password, String url, localDir) &#123; ant.taskdef( name: &apos;ftp&apos;, classname: &apos;org.apache.tools.ant.taskdefs.optional.net.FTP&apos;, classpath: configurations.ftpAntTask.asPath ) //指定ftp地址及账户信息 ant.ftp(action: &apos;get&apos;, server: serverIp, userid: userId, password: password, remotedir: url) &#123; // 删除老文件 delete(new File(localDir)) //指定下载文件位置 fileset(dir: new File(localDir)) &#123; include(name: &quot;**&quot;) &#125; &#125;&#125;//导出函数ext &#123; downloadFtpFiles = this.&amp;downloadFtpFiles&#125; 使用方式：导入方式：将ftp-util.gradle文件放在根目录下然后使用一下代码导入groovy代码 1apply from: "$&#123;project.rootProject.file('ftp-util.gradle')&#125;" 下载任务 12345678910111213141516171819202122task downloadFiles() &#123; //清理缓存 dependsOn 'clean' def dir = buildDir.getPath() + '/dir' doLast &#123; //获取最新版本信息 ant &#123; println 'web-ftp:serverIp:' + serverIp println 'web-ftp:userId:' + userId println 'web-ftp:password:' + password println 'web-ftp:dir:' + dir println 'web-ftp:sync start' def url = webUrl + '/latest' //调用FTP插件下载文件函数 downloadFtpFiles(serverIp, userId, password, url, dir) println 'web-ftp:sync end' &#125; &#125;&#125; 调用task方式1./gradlew downloadFiles]]></content>
      <categories>
        <category>gradle</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>FTP</tag>
        <tag>下载</tag>
        <tag>FTP文件下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之Context概述]]></title>
    <url>%2F2019%2F09%2F06%2FAndroid%E4%B9%8BContext%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Context概述官方注释信息：1234567891011/** * Interface to global information about an application environment. This is * an abstract class whose implementation is provided by * the Android system. It * allows access to application-specific resources and classes, as well as * up-calls for application-level operations such as launching activities, * broadcasting and receiving intents, etc. */public abstract class Context &#123;...&#125; 与有关应用程序环境的全局信息的接口。这是一个抽象类，其实现由android系统提供。它允许访问特定于应用程序的资源和类，以及对应用程序级操作（如启动活动、广播和接收意图等）的向上调用。 关联：Android应用Context详解及源码解析 关联：Android Context完全解析，你所不知道的Context的各种细节]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之ImageView宽高适配]]></title>
    <url>%2F2019%2F06%2F06%2FAndroid%E4%B9%8BImageView%E5%AE%BD%E9%AB%98%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Android ImageView图片宽度为控件宽度，高度按比例缩放实现方式在Java代码里面实现首先，定义ImageView，在该ImageView中，我们需要设置属性android:adjustViewBounds=”true”，他的意思图片是否保持宽高比。切记的一点是该属性需要与maxWidth、MaxHeight一起使用，否则单独使用没有效果。 1234567&lt;ImageView android:id="@+id/img_list" android:layout_width="fill_parent" android:layout_height="wrap_content" android:scaleType="centerCrop" android:adjustViewBounds="true" android:src="@drawable/load_default_img" /&gt; 刚刚说了，android:adjustViewBounds=”true”必须与MaxHeight一起使用才能有效，所以，我要设置该ImageView的最大高度MaxHeight： 12345678int screenWidth = getScreenWidth(this); // 获取屏幕宽度aViewGroup.LayoutParams lp = testImage.getLayoutParams();lp.width = screenWidth;lp.height = LayoutParams.WRAP_CONTENT;testImage.setLayoutParams(lp); testImage.setMaxWidth(screenWidth);testImage.setMaxHeight(screenWidth * 5); //这里其实可以根据需求而定，我这里测试为最大宽度的5倍 在Xml中实现123456&lt;ImageView android:layout_width="match_parent" android:layout_height="wrap_content" android:scaleType="centerCrop" android:adjustViewBounds="true" android:src="@drawable/ic_login_bg" /&gt; 参考：1、Android 设置ImageView宽度固定，其高度按比例缩放适应]]></content>
      <categories>
        <category>Android</category>
        <category>view</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>view</tag>
        <tag>ImageView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信X5之WebView使用]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%BE%AE%E4%BF%A1X5%E4%B9%8BWebView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#微信X5之WebView使用 X5之WebView属性配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 private WebViewClient client = new WebViewClient() &#123; /** * 防止加载网页时调起系统浏览器 */ public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); return true; &#125;&#125;;public X5WebView(Context arg0) &#123; super(arg0); setBackgroundColor(85621);&#125;@SuppressLint("SetJavaScriptEnabled")public X5WebView(Context arg0, AttributeSet arg1) &#123; super(arg0, arg1); this.setWebViewClient(client); // this.setWebChromeClient(chromeClient); // WebStorage webStorage = WebStorage.getInstance(); initWebViewSettings(); this.getView().setClickable(true);&#125; private void initWebViewSettings() &#123; WebSettings webSetting = this.getSettings(); webSetting.setJavaScriptEnabled(true); webSetting.setJavaScriptCanOpenWindowsAutomatically(true); webSetting.setAllowFileAccess(true); webSetting.setLayoutAlgorithm(LayoutAlgorithm.NARROW_COLUMNS); webSetting.setSupportZoom(true); webSetting.setBuiltInZoomControls(true); webSetting.setUseWideViewPort(true); webSetting.setSupportMultipleWindows(true); // webSetting.setLoadWithOverviewMode(true); webSetting.setAppCacheEnabled(true); // webSetting.setDatabaseEnabled(true); webSetting.setDomStorageEnabled(true); webSetting.setGeolocationEnabled(true); webSetting.setAppCacheMaxSize(Long.MAX_VALUE); // webSetting.setPageCacheCapacity(IX5WebSettings.DEFAULT_CACHE_CAPACITY); webSetting.setPluginState(WebSettings.PluginState.ON_DEMAND); // webSetting.setRenderPriority(WebSettings.RenderPriority.HIGH); webSetting.setCacheMode(WebSettings.LOAD_NO_CACHE); // this.getSettingsExtension().setPageCacheCapacity(IX5WebSettings.DEFAULT_CACHE_CAPACITY);//extension // settings 的设计&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CrossWalk之XWalkView使用]]></title>
    <url>%2F2019%2F05%2F16%2FCrossWalk%E4%B9%8BXWalkView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#XwalkView使用 XwalkView属性配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546@SuppressLint("SetJavaScriptEnabled") public void init() &#123; if (BuildConfig.DEBUG) &#123; XWalkPreferences.setValue(XWalkPreferences.REMOTE_DEBUGGING, true); &#125; //声明WebSettings子类 XWalkSettings webSettings = getSettings(); //如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript webSettings.setJavaScriptEnabled(true); // 若加载的 html 里有JS 在执行动画等操作，会造成资源浪费（CPU、电量） // 在 onStop 和 onResume 里分别把 setJavaScriptEnabled() 给设置成 false 和 true 即可 //支持插件 //webSettings.setPluginsEnabled(true); //设置自适应屏幕，两者合用 //将图片调整到适合webview的大小 webSettings.setUseWideViewPort(true); //缩放至屏幕的大小 webSettings.setLoadWithOverviewMode(true); //缩放操作 //支持缩放，默认为true。是下面那个的前提。 webSettings.setSupportZoom(true); //设置内置的缩放控件。若为false，则该WebView不可缩放 webSettings.setBuiltInZoomControls(true); //webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件 //其他细节操作 //关闭webview中缓存 webSettings.setCacheMode(WebSettings.LOAD_NO_CACHE); //设置可以访问文件 webSettings.setAllowFileAccess(true); //支持通过JS打开新窗口 webSettings.setJavaScriptCanOpenWindowsAutomatically(true); //支持自动加载图片 webSettings.setLoadsImagesAutomatically(true); //webSettings.setDefaultTextEncodingName("utf-8");//设置编码格式 //设置背景为白色 setBackgroundColor(Color.WHITE); //设置排序 setZOrderOnTop(true); Log.i("XwalkViewWebContainer", "Version:" + getXWalkVersion()); &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>WebView</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统WebView使用]]></title>
    <url>%2F2019%2F05%2F16%2FAndroid%E7%B3%BB%E7%BB%9FWebView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#Android系统WebView使用 WebView属性配置123456789101112131415161718192021222324252627282930public void init() &#123; if (BuildConfig.DEBUG) &#123; setWebContentsDebuggingEnabled(true); &#125; //声明WebSettings子类 WebSettings webSettings = getSettings(); //如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript webSettings.setJavaScriptEnabled(true); // 若加载的 html 里有JS 在执行动画等操作，会造成资源浪费（CPU、电量） // 在 onStop 和 onResume 里分别把 setJavaScriptEnabled() 给设置成 false 和 true 即可 //支持插件 //webSettings.setPluginsEnabled(true); //设置自适应屏幕，两者合用 webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小 webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小 //缩放操作 webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。 webSettings.setBuiltInZoomControls(true); //设置内置的缩放控件。若为false，则该WebView不可缩放 webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件 //其他细节操作 webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //关闭webview中缓存 webSettings.setAllowFileAccess(true); //设置可以访问文件 webSettings.setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口 webSettings.setLoadsImagesAutomatically(true); //支持自动加载图片 webSettings.setDefaultTextEncodingName("utf-8");//设置编码格式&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>WebView</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识（转&添加）]]></title>
    <url>%2F2019%2F05%2F15%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Java基础知识（转&amp;添加）[TOC] java中“==”和equals的区别以及hashCode的区别==概述==即可以比较基本类型数据也可以比较对象数据，进行基本数据类型比较时比较的是值，进行对象比较时比较的是对象的内存地址。 equals概述它的作用也是判断两个对象是否相等。equals只能比较对象，即使Objects.equals()”可以”比较两个基本值类型变量，但它实际上比较的时自动装箱过后的值类型对应的对象。IDE也会建议用==比较基本数据类型。但equals一般有两种使用情况： 情况一：类没有覆盖equals()方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况二：类有覆盖equals()方法。一般，我们都覆盖 equals() 方法来判断两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 举个例子：1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String("ab"); // a 为一个引用 String b = new String("ab"); // b为另一个引用,对象的内容一样 String aa = "ab"; // 放在常量池中 String bb = "ab"; // 从常量池中查找 if (aa == bb) // true System.out.println("aa==bb"); if (a == b) // false，非同一对象 System.out.println("a==b"); if (a.equals(b)) // true System.out.println("aEQb"); if (42 == 42.0) &#123; // true System.out.println("true"); &#125; &#125;&#125; 注： String是对象类型，继承了Object，但是它是重写了equals()方法的，因为object中的equals是比较的对象内存地址，String比较的是对象的值 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 hashCode 与 equals面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？” hashCode（）介绍hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode 我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 通过上述我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 hashCode（）与equals（）的相关规定 如果两个对象相等，则hashcode一定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 推荐阅读：Java hashCode() 和 equals()的若干问题解答 基本数据类型各占多少字节、多少位注：bit 位 类型 名字 字节（8bit） 位 byte 字节 1 1*8 char 字符 2 2*8=16 short 短整型 2 2*8=16 int 整形 4 4*8=32 long 长整型 8 8*8=64 float 单精度浮点数 4 4*8=32 double 双精度浮点型 8 8*8=64 boolean 布尔值 - - 注：boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。 Primitive Data Types The Java® Virtual Machine Specification 包装类型 int与Integer的区别基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 面向对象思想封装利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。 优点： 减少耦合：可以独立地开发、测试、优化、使用、理解和修改 减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块 有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能 提高软件的可重用性 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。 注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。 12345678910111213141516171819202122public class Person &#123; private String name; private int gender; private int age; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender == 0 ? "man" : "woman"; &#125; public void work() &#123; if (18 &lt;= age &amp;&amp; age &lt;= 50) &#123; System.out.println(name + " is working very hard!"); &#125; else &#123; System.out.println(name + " can't work any more!"); &#125; &#125;&#125; 继承继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。 继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。 Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。 1Animal animal = new Cat(); 多态多态分为编译时多态和运行时多态： 编译时多态主要指方法的重载 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定 运行时多态有三个条件： 继承 覆盖（重写） 向上转型 下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。 1234567891011121314151617181920212223242526272829303132public class Instrument &#123; public void play() &#123; System.out.println("Instument is playing..."); &#125;&#125;public class Wind extends Instrument &#123; public void play() &#123; System.out.println("Wind is playing..."); &#125;&#125;public class Percussion extends Instrument &#123; public void play() &#123; System.out.println("Percussion is playing..."); &#125;&#125;public class Music &#123; public static void main(String[] args) &#123; List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;(); instruments.add(new Wind()); instruments.add(new Percussion()); for(Instrument instrument : instruments) &#123; instrument.play(); &#125; &#125;&#125; String、StringBuffer、StringBuilder区别1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StackOverflow : String, StringBuffer, and StringBuilder 什么是内部类？内部类的作用Java内部类详解 在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法 内部类分类成员内部类成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式： 123456789101112131415class Circle &#123; double radius = 0; public Circle(double radius) &#123; this.radius = radius; &#125; //内部类 class Draw &#123; public void drawSahpe() &#123; System.out.println( "drawshape" ); &#125; &#125;&#125; 这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 1234567891011121314class Circle &#123; private double radius = 0; public static int count =1; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 &#125; &#125;&#125; 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); &#125;&#125; class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 123456789101112131415161718class People&#123; public People() &#123; &#125;&#125; class Man&#123; public Man()&#123; &#125; public People getWoman()&#123; class Woman extends People&#123; //局部内部类 int age =0; &#125; return new Woman(); &#125;&#125; 注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。 匿名内部类匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码： 1234567891011121314151617scan_bt.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125;); history_bt.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125; &#125;); 这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的： 12345678new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125; &#125; 就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。 123456789101112131415161718192021private void setListener()&#123; scan_bt.setOnClickListener(new Listener1()); history_bt.setOnClickListener(new Listener2());&#125; class Listener1 implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; class Listener2 implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub &#125;&#125; 这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); &#125;&#125; class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 内部类的作用 内部类可以很好的实现隐藏 一般的非内部类，是不允许有 private 与protected权限的，但内部类可以 内部类拥有外围类的所有元素的访问权限 为什么可以引用：内部类虽然和外部类写在同一个文件中， 但是编译完成后， 还是生成各自的class文件，内部类通过this访问外部类的成员。 编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象(this)的引用； 编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为内部类中添加的成员变量赋值； 在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。 可是实现多重继承 我们知道 java 是不允许使用 extends 去继承多个类的。内部类的引入可以很好的解决这个事情。以下引用 《Thinking In Java》中的一段话： 每个内部类都可以队里的继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类没有影响如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就难以解决。接口解决了部分问题，一个类可以实现多个接口，内部类允许继承多个非接口类型（类或抽象类）。 我的理解 Java只能继承一个类这个学过基本语法的人都知道，而在有内部类之前它的多重继承方式是用接口来实现的。但使用接口有时候有很多不方便的地方。比如我们实现一个接口就必须实现它里面的所有方法。而有了内部类就不一样了。它可以使我们的类继承多个具体类或抽象类。 可以避免修改接口而实现同一个类中两种同名方法的调用 抽象类和接口区别抽象类和接口区别 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 抽象类的意义定义：如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 抽象类总结规定： 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 抽象类与接口的应用场景interface的应用场合 类与类之前需要特定的接口进行协调，而不在乎其如何实现。 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。 abstract class的应用场合一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有： 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能 抽象类是否可以没有方法和属性？ 抽象类专用于派生出子类，子类必须实现抽象类所声明的抽象方法，否则，子类仍是抽象类。 包含抽象方法的类一定是抽象类，但抽象类中的方法不一定是抽象方法。 抽象类中可以没有抽象方法，但有抽象方法的一定是抽象类。所以，java中 抽象类里面可以没有抽象方法。比如HttpServlet类。抽象类和普通类的区别就在于，抽象类不能被实例化，就是不能被new出来，即使抽象类里面没有抽象方法。 抽象类的作用在于子类对其的继承和实现，也就是多态；而没有抽象方法的抽象类的存在价值在于：实例化了没有意义，因为类已经定义好了，不能改变其中的方法体，但是实例化出来的对象却满足不了要求，只有继承并重写了他的子类才能满足要求。所以才把它定义为没有抽象方法的抽象类 接口的意义简单地说：接口的作用就是把使用接口的人和实现接口的人分开，实现接口的人不必要关心谁去使用，而使用接口的人也不用关心实现的细节。4点关于JAVA中接口存在的意义： 重要性：在Java语言中， abstract class 和interface 是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的 面向对象能力。 简单、规范性：如果一个项目比较庞大，那么就需要一个能理清所有业务的架构师来定义一些主要的接口，这些接口不仅告诉开发人员你需要实现那些业务，而且也将命名规范限制住了（防止一些开发人员随便命名导致别的程序员无法看明白）。 维护、拓展性：比如有一个类，实现了某个功能，突然有一天，发现这个类满足不了需求了，然后又要重新设计这个类，更糟糕是你可能要放弃这个类，那么其他地方可能有引用他，这样修改起来很麻烦。 如果一开始定义一个接口，把功能放在接口里，然后定义类时实现这个接口，然后只要用这个接口去引用实现它的类就行了，以后要换的话只不过是引用另一个类而已，这样就达到维护、拓展的方便性。比如有个method1的方法，如果用接口，【接口名】 【对象名】=new 【实现接口的类】，这样想用哪个类的对象就可以new哪个对象了，new a（）；就是用a的方法，new b（）就是用b的方法，就和USB接口一样，插什么读什么，就是这个原理。 你要做一个画板程序，其中里面有一个面板类，主要负责绘画功能，然后你就这样定义了这个类。 安全、严密性：接口是实现软件松耦合的重要手段，它描叙了系统对外的所有服务，而不涉及任何具体的实现细节。这样就比较安全、严密一些（一般软件服务商考虑的比较多，jdk中很多方法就是实现了某个接口）。 泛型中extends和super的区别【Java】泛型中 extends 和 super 的区别 父类的静态方法能否被子类重写 答案：不能 原因：因为静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，也就是该静态方法。子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说。 进程和线程的区别进程和线程的区别进程和线程的区别（故事版） final，finally，finalize的区别 final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承. finally 是异常处理语句结构的一部分，表示总是执行. finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用. 序列化定义 序列化（serialization）定义：在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。 序列化在计算机科学中通常有以下定义: 对同步控制而言，表示强制在同一时间内进行单一访问。 在数据储存与发送的部分是指将一个对象存储至一个存储介质，例如文件或是存储器缓冲等，或者透过网络发送数据时进行编码的过程，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这程序被应用在不同应用程序之间发送对象，以及服务器将对象存储到文件或数据库。相反的过程又称为反序列化。 简单地说，“序列化”就是将运行时的对象状态转换成二进制，然后保存到流、内存或者通过网络传输给其他端。 序列化参考：Android 进阶6：两种序列化方式 Serializable 和 Parcelable 方式Android中序列化方式有两种： Serializable Parcelable 两者都是支持序列化和反序列化的操作。 区别 API Serializable是Java API，Parcelable是Android的API 效率Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作， Parcelable 自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多。 总结：可以看到，Serializable 的使用比较简单，创建一个版本号即可；而 Parcelable 则相对复杂一些，会有四个方法需要实现。 一般在保存数据到 SD 卡或者网络传输时建议使用 Serializable 即可，虽然效率差一些，好在使用方便。 而在运行时数据传递时建议使用 Parcelable，比如 Intent，Bundle 等，Android 底层做了优化处理，效率很高。 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？参考一：https://www.cnblogs.com/kabi/p/5181941.html参考二：https://blog.csdn.net/jinyongqing/article/details/7669605 静态内部类的设计意图参考一：https://zhuanlan.zhihu.com/p/29623665 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用参考一：https://www.cnblogs.com/chenssy/p/3388487.html 谈谈对kotlin的理解参考一：http://shinelw.com/2017/03/17/kotlin-apply-in-coding/ 闭包和局部内部类的区别参考一：https://blog.csdn.net/u010412719/article/details/49453235 string 转换成 integer的方式及原理参考一：https://blog.csdn.net/itboy_libing/article/details/80393530]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制]]></title>
    <url>%2F2019%2F03%2F26%2FAndroid%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android事件分发机制1、概述 本次分享有一个非常重要的概念：View，虽然说View不属于四大组件，但是它的作用堪比四大组件，甚至比Receiver和Provider的重要性都要大。在Android开发中，Activity承担这可视化的功能，同时Android系统提供了很多基础控件，常见的有Button、TextView、CheckBox等。很多时候仅仅使用系统提供的控件是不能满足需求的，因此我们就需要能够根据需求进行新控件的定义，而控件的自定义就需要对Android的View体系有深入的理解，只有这样才能写出完美的自定义控件。同时Android手机属于移动设备，移动设备的一个特点就是用户可以直接通过屏幕来进行一系列操作，一个典型的场景就是屏幕的滑动，用户可以通过滑动来切换到不同的界面。很多情况下我们的应用都需要支持滑动操作，当处于不同层级的View都可以响应用户的滑动操作时，就会带来一个问题，那就是滑动冲突。如何解决滑动冲突呢？这对于初学者来说的确是个头疼的问题，其实解决滑动冲突本不难，它需要读者对View的事件分发机制有一定的了解，在这个基础上，我们就可以利于这个特性从而得出滑动冲突的解决方法。 ——摘自Android开发艺术探索 2、事件分发概述 事件指的是什么呢？就是指用户触摸屏幕产生的Touch事件；在Android中它被封装成MotionEvent。 3、常用MotionEvent分类 ACTION_DOWN：按下View（其他所有事件的开始）。 ACTION_UP：抬起View（与DOWN对应）。 ACTION_MOVE：滑动View。 ACTION_CANCEL：结束事件（非人为原因）。 其余事件：ACTION_MASK、ACTION_OUTSIDE、ACTION_POINTER_DOWN、ACTION_POINTER_UP、ACTION_HOVER_MOVE、ACTION_SCROLL、ACTION_HOVER_ENTER、ACTION_HOVER_EXIT、ACTION_BUTTON_PRESS、ACTION_BUTTON_RELEASE、ACTION_POINTER_INDEX_MASK、ACTION_POINTER_INDEX_SHIFT；有兴趣的可以下来自己了解。 3、事件产生顺序 4、Android事件扭转流程模拟：经理分派任务，下属处理这个任务的过程。 View层次示例 View内部事件处理流程图： 5、事件分发流程及其分析流程图及注释 流程分析 流程1:在Activity#dispatchTouchEvent返回false/true当前流程是在Activity#dispatchTouchEvent拦截并消费事件，不再往下传递 03-26 18:54:58.178 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:0 流程2:在ViewGroup#dispatchTouchEvent返回true：当前流程是ViewGroup#dispatchTouchEvent拦截并消费事件，事件不再往下传递 03-26 19:08:23.268 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:08:23.268 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:0 流程3:在ViewGroup#dispatchTouchEvent返回false：当前流程是停止往当前ViewGroup及其子View事件，并将当前事件交由父类onTouchEvent处理。 03-26 19:09:15.238 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:09:15.238 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:003-26 19:09:15.238 com.android.api23 I/com.android.api23.MainActivity: onTouchEvent#event:0 流程4:在ViewGroup#onInterceptTouchEvent返回true： 03-26 19:07:02.918 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:07:02.918 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:003-26 19:07:02.918 com.android.api23 I/com.android.api23.MyViewGroup: onInterceptTouchEvent#event:003-26 19:07:02.918 com.android.api23 I/com.android.api23.MyViewGroup: onTouchEvent#event:003-26 19:07:02.918 com.android.api23 I/com.android.api23.MainActivity: onTouchEvent#event:0 在ViewGroup#onInterceptTouchEvent返回false当前流程为系统默认流程即：ViewGroup不拦截事件，事件将往下一级传递 03-26 19:06:11.008 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:06:11.018 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:003-26 19:06:11.018 com.android.api23 I/com.android.api23.MyViewGroup: onInterceptTouchEvent#event:003-26 19:06:11.018 com.android.api23 I/com.android.api23.MyView: dispatchTouchEvent#event:003-26 19:06:11.018 com.android.api23 I/com.android.api23.MyView: onTouchEvent#event:003-26 19:06:11.018 com.android.api23 I/com.android.api23.MyViewGroup: onTouchEvent#event:003-26 19:06:11.018 com.android.api23 I/com.android.api23.MainActivity: onTouchEvent#event:0 流程5:在View#dispatchTouchEvent返回true：当前流程是ViewGroup#dispatchTouchEvent拦截并消费事件，事件不再往下传递 03-26 19:10:41.048 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:10:41.048 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:003-26 19:10:41.048 com.android.api23 I/com.android.api23.MyViewGroup: onInterceptTouchEvent#event:003-26 19:10:41.048 com.android.api23 I/com.android.api23.MyView: dispatchTouchEvent#event:0 流程6:在View#dispatchTouchEvent返回false： 03-26 19:11:36.458 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:11:36.458 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:003-26 19:11:36.458 com.android.api23 I/com.android.api23.MyViewGroup: onInterceptTouchEvent#event:003-26 19:11:36.458 com.android.api23 I/com.android.api23.MyView: dispatchTouchEvent#event:003-26 19:11:36.458 com.android.api23 I/com.android.api23.MyViewGroup: onTouchEvent#event:003-26 19:11:36.458 com.android.api23 I/com.android.api23.MainActivity: onTouchEvent#event:0 流程7:在View#onTouchEvent返回true： 03-26 19:12:51.688 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:12:51.688 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:003-26 19:12:51.688 com.android.api23 I/com.android.api23.MyViewGroup: onInterceptTouchEvent#event:003-26 19:12:51.688 com.android.api23 I/com.android.api23.MyView: dispatchTouchEvent#event:003-26 19:12:51.688 com.android.api23 I/com.android.api23.MyView: onTouchEvent#event:0 在View#onTouchEvent返回false：当前流程为系统默认流程 03-26 19:13:58.188 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:13:58.188 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:003-26 19:13:58.188 com.android.api23 I/com.android.api23.MyViewGroup: onInterceptTouchEvent#event:003-26 19:13:58.188 com.android.api23 I/com.android.api23.MyView: dispatchTouchEvent#event:003-26 19:13:58.188 com.android.api23 I/com.android.api23.MyView: onTouchEvent#event:003-26 19:13:58.188 com.android.api23 I/com.android.api23.MyViewGroup: onTouchEvent#event:003-26 19:13:58.188 com.android.api23 I/com.android.api23.MainActivity: onTouchEvent#event:0 流程8:在ViewGroup#onTouchEvent返回true： 03-26 19:15:14.608 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:15:14.608 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:003-26 19:15:14.608 com.android.api23 I/com.android.api23.MyViewGroup: onInterceptTouchEvent#event:003-26 19:15:14.608 com.android.api23 I/com.android.api23.MyView: dispatchTouchEvent#event:003-26 19:15:14.608 com.android.api23 I/com.android.api23.MyView: onTouchEvent#event:003-26 19:15:14.608 com.android.api23 I/com.android.api23.MyViewGroup: onTouchEvent#event:0 在ViewGroup#onTouchEvent返回false：当前流程为系统默认流程 03-26 19:16:48.928 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:16:48.928 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:003-26 19:16:48.928 com.android.api23 I/com.android.api23.MyViewGroup: onInterceptTouchEvent#event:003-26 19:16:48.928 com.android.api23 I/com.android.api23.MyView: dispatchTouchEvent#event:003-26 19:16:48.928 com.android.api23 I/com.android.api23.MyView: onTouchEvent#event:003-26 19:16:48.928 com.android.api23 I/com.android.api23.MyViewGroup: onTouchEvent#event:003-26 19:16:48.928 com.android.api23 I/com.android.api23.MainActivity: onTouchEvent#event:0 流程9:在Activity#onTouchEvent返回true： 03-26 19:18:49.648 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:18:49.648 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:003-26 19:18:49.648 com.android.api23 I/com.android.api23.MyViewGroup: onInterceptTouchEvent#event:003-26 19:18:49.648 com.android.api23 I/com.android.api23.MyView: dispatchTouchEvent#event:003-26 19:18:49.648 com.android.api23 I/com.android.api23.MyView: onTouchEvent#event:003-26 19:18:49.648 com.android.api23 I/com.android.api23.MyViewGroup: onTouchEvent#event:003-26 19:18:49.648 com.android.api23 I/com.android.api23.MainActivity: onTouchEvent#event:0 在Activity#onTouchEvent返回false：当前流程为系统默认流程 03-26 19:20:07.738 com.android.api23 I/com.android.api23.MainActivity: dispatchTouchEvent#event:003-26 19:20:07.738 com.android.api23 I/com.android.api23.MyViewGroup: dispatchTouchEvent#event:003-26 19:20:07.738 com.android.api23 I/com.android.api23.MyViewGroup: onInterceptTouchEvent#event:003-26 19:20:07.738 com.android.api23 I/com.android.api23.MyView: dispatchTouchEvent#event:003-26 19:20:07.738 com.android.api23 I/com.android.api23.MyView: onTouchEvent#event:003-26 19:20:07.738 com.android.api23 I/com.android.api23.MyViewGroup: onTouchEvent#event:003-26 19:20:07.738 com.android.api23 I/com.android.api23.MainActivity: onTouchEvent#event:0 AndroidApi23：Android事件分发机制测试Demo]]></content>
      <categories>
        <category>Android</category>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序之文件系统初探]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[微信小程序之文件系统初探1、文件下载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 //下载文件go_download: function() &#123; var content = this; var baseUrl = "http://rwh.blob.core.chinacloudapi.cn"; var fileName = "1-e2b214af930149ee80c8142d067148a7.exam"; var url = baseUrl + "/data/ExamBuilder2.0/20190320" + "/" + fileName; console.log("dowload url:" + url); //用户缓存目录 var userLocalPath = wx.env.USER_DATA_PATH; var localPath = "wxfile://"; var path = userLocalPath + "/" + fileName var localPath = localPath + "/" + fileName var authorization = "Basic ZThlYWJmNWMwN2I0NGI0YmEzOGJmZWMyMTJkM2U1ZDU="; var apptoken = "Authorization" const downloadTask = wx.downloadFile(&#123; // 待下载的云资源 url: url, //下载成功后的回调函数 success(res) &#123; console.log("dowload res.errMsg:" + res.errMsg); console.log("dowload res.statusCode:" + res.statusCode); console.log("dowload res.tempFilePath:" + res.tempFilePath); if (res.statusCode === 200) &#123; wx.showToast(&#123; title: '下载成功！' &#125;) &#125; &#125;, //失败回调函数 fai: function(res) &#123; console.log("downloadFile fai:" + res.errMsg) &#125;, //完成回调函数 complete: function() &#123; console.log("downloadFile complete") content.getReaddir(targPath) &#125; &#125;) downloadTask.onProgressUpdate((res) =&gt; &#123; console.log('下载进度', res.progress) console.log('已经下载的数据长度', res.totalBytesWritten) console.log('预期需要下载的数据总长度', res.totalBytesExpectedToWrite) &#125;) // downloadTask.abort() // 取消下载任务&#125; 2、持久化文件到本地1234567891011 //下载成功的文件目前存在temp文件夹下，它属于临时文件 //如果想要将其持久化，需要使用wx.saveFile()将其保存至store文件夹下， //在使用这个函数时，temp文件夹下的临时文件会被删除。wx.saveFile(&#123; tempFilePath: res.tempFilePath, success: function(res) &#123; console.log(res); var savedFilePath = res.savedFilePath; console.log(&apos;文件已下载到&apos; + savedFilePath); &#125; &#125;) 3、解压压缩文件1234567891011121314151617181920212223242526272829//解压文件unzipFile: function(path, targPath) &#123; var content = this; console.log(&quot;unzip path:&quot; + path) console.log(&quot;unzip targPath:&quot; + targPath) wx.getFileSystemManager().unzip(&#123; //文件路径 zipFilePath: path, //目标文件夹 targetPath: targPath, //成功回调函数 success: function(res) &#123; console.log(res.errMsg) &#125;, //失败回调函数 fai: function(res) &#123; console.log(&quot;unzip fai:&quot; + res.errMsg) &#125;, //完成回调函数 complete: function() &#123; console.log(&quot;unzip complete&quot;) content.getReaddir(targPath) &#125; &#125;);&#125; 3、读取文件到内存12345678910111213141516171819202122232425//读取文件 readFile: function(path) &#123; console.log(&quot;readFile start path:&quot; + path) var userLocalPath = wx.env.USER_DATA_PATH; wx.getFileSystemManager().readFile(&#123; //文件路径 filePath: path, //成功回调函数 success: function(res) &#123; console.log(&quot;unzip success res:&quot; + res.errMsg) console.log(res) &#125;, //失败回调函数 fai: function(res) &#123; console.log(&quot;unzip fai:&quot; + res.errMsg) &#125;, //完成回调函数 complete: function() &#123; console.log(&quot;unzip complete&quot;) &#125; &#125;); &#125; 4、查看目标文件夹的文件列表1234567891011121314151617181920212223// 查看下载的文件列表 getReaddir: function(path) &#123; console.log("getReaddir start") wx.getFileSystemManager().readdir(&#123; dirPath: path, //成功回调函数 success: function(res) &#123; console.log("getReaddir success res:" + res.errMsg) console.log(res) &#125;, //失败回调函数 fai: function(res) &#123; console.log("getReaddir fai:" + res.errMsg) &#125;, //完成回调函数 complete: function() &#123; console.log("getReaddir complete") &#125; &#125;) &#125; 5、查看已经缓存的文件列表123456789101112131415161718192021// 查看下载的文件列表 getUserSavedFileList: function() &#123; console.log("getUserSavedFileList start") wx.getFileSystemManager().getSavedFileList(&#123; //成功回调函数 success: function(res) &#123; console.log("getUserSavedFileList success res:" + res) console.log(res) &#125;, //失败回调函数 fai: function(res) &#123; console.log("getUserSavedFileList fai:" + res.errMsg) &#125;, //完成回调函数 complete: function() &#123; console.log("getUserSavedFileList complete") &#125; &#125;) &#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2F2019%2F03%2F14%2F%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[责任链模式责任链模式：责任链模式在面向对象程式设计里是一种软件设计模式，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。—维基百科 1234567891011121314151617181920212223242526272829303132import java.util.*;abstract class Logger &#123; public static int ERR = 3; public static int NOTICE = 5; public static int DEBUG = 7; protected int mask; // The next element in the chain of responsibility protected Logger next; public Logger setNext( Logger l) &#123; next = l; return this; &#125; public final void message( String msg, int priority ) &#123; if ( priority &lt;= mask ) &#123; writeMessage( msg ); if ( next != null ) &#123; next.message( msg, priority ); &#125; &#125; &#125; protected abstract void writeMessage( String msg );&#125; 1234567891011class StdoutLogger extends Logger &#123; public StdoutLogger( int mask ) &#123; this.mask = mask; &#125; protected void writeMessage( String msg ) &#123; System.out.println( "Writting to stdout: " + msg ); &#125;&#125; 12345678910class EmailLogger extends Logger &#123; public EmailLogger( int mask ) &#123; this.mask = mask; &#125; protected void writeMessage( String msg ) &#123; System.out.println( "Sending via email: " + msg ); &#125;&#125; 12345678910class StderrLogger extends Logger &#123; public StderrLogger( int mask ) &#123; this.mask = mask; &#125; protected void writeMessage( String msg ) &#123; System.out.println( "Sending to stderr: " + msg ); &#125;&#125; 12345678910111213141516171819public class ChainOfResponsibilityExample&#123; public static void main( String[] args ) &#123; // Build the chain of responsibility Logger l = new StdoutLogger( Logger.DEBUG).setNext( new EmailLogger( Logger.NOTICE ).setNext( new StderrLogger( Logger.ERR ) ) ); // Handled by StdoutLogger l.message( "Entering function y.", Logger.DEBUG ); // Handled by StdoutLogger and EmailLogger l.message( "Step1 completed.", Logger.NOTICE ); // Handled by all three loggers l.message( "An error has occurred.", Logger.ERR ); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git如何把本地代码推送到远程仓库]]></title>
    <url>%2F2019%2F03%2F08%2FGit%E5%A6%82%E4%BD%95%E6%8A%8A%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1、 初始化版本库1$ git init 2、 添加文件到版本库（只是添加到缓存区），.代表添加文件夹下所有文件1$ git add . 3、 把添加的文件提交到版本库，并填写提交备注1$ git commit -m &quot;first commit&quot; 4、 把本地库与远程库关联1$ git remote add origin 远程库地址 5、 第一次推送时1$ git push -u origin master 6、第一次推送后，直接使用该命令即可推送修改1$ git push origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>版本回滚</tag>
        <tag>commit</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volatile 原理及作用]]></title>
    <url>%2F2019%2F03%2F08%2FVolatile%20%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[—— 维基百科Java也支持volatile关键字，但它被用于其他不同的用途。当volatile用于一个作用域时，Java保证如下： （适用于Java所有版本）读和写一个volatile变量有全局的排序。也就是说每个线程访问一个volatile作用域时会在继续执行之前读取它的当前值，而不是（可能）使用一个缓存的值。(但是并不保证经常读写volatile作用域时读和写的相对顺序，也就是说通常这并不是有用的线程构建)。 （适用于Java5及其之后的版本）volatile的读和写建立了一个happens-before关系，类似于申请和释放一个互斥锁[示例]。 使用volatile会比使用锁更快，但是在一些情况下它不能工作。volatile使用范围在Java5中得到了扩展，特别是双重检查锁定现在能够正确工作[示例]。 资料 1、维基百科资料 2、Java并发编程：volatile关键字解析资料 3、Java中缓存的原理]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文摘自维基百科 单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。 —— 维基百科 实现单例模式的思路：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。 通常单例模式在Java语言中，有两种构建方式： 懒汉方式：指全局的单例实例在第一次被使用时构建。 饿汉方式：指全局的单例实例在类装载时构建。 Java在Java语言中，单例模式(饿汉模式)应用的例子如下述代码所示： 1234567891011public class Singleton &#123; private final static Singleton INSTANCE = new Singleton(); // Private constructor suppresses private Singleton() &#123;&#125; // default public constructor public static Singleton getInstance() &#123; return INSTANCE; &#125;&#125; 在Java编程语言中，单例模式(懒汉模式)应用的例子如下述代码所示 (此种方法只能用在JDK5及以后版本(注意 INSTANCE 被声明为 volatile)，之前的版本使用“双重检查锁”会发生非预期行为[1])： 123456789101112131415161718192021public class Singleton &#123; private static volatile Singleton INSTANCE = null; // Private constructor suppresses // default public constructor private Singleton() &#123;&#125; //thread safe and performance promote public static Singleton getInstance() &#123; if(INSTANCE == null)&#123; synchronized(Singleton.class)&#123; //when more than two threads run into the first null check same time, to avoid instanced more than one time, it needs to be checked again. if(INSTANCE == null)&#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单利模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程`同步`有几种方式]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1、使用synchronized（可同步代码片段也可同步整个函数） synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 代码如: 12public synchronized void test()&#123; &#125; 注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类 synchronized同步代码块即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步 代码如： 12synchronized(object)&#123; &#125; 注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 2、使用重入锁实现线程同步在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有： ReentrantLock() : 创建一个ReentrantLock实例 lock() : 获得锁 *unlock() *: 释放锁123456789101112131415161718class Bank &#123; private int account = 100; //需要声明这个锁 private Lock lock = new ReentrantLock(); public int getAccount() &#123; return account; &#125; //这里不再需要synchronized public void save(int money) &#123; lock.lock(); try&#123; account += money; &#125;finally&#123; lock.unlock(); &#125; &#125; ｝ 注：关于Lock对象和synchronized关键字的选择：a.最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git回滚代码到某个commit]]></title>
    <url>%2F2019%2F03%2F08%2FGit%E5%9B%9E%E6%BB%9A%E4%BB%A3%E7%A0%81%E5%88%B0%E6%9F%90%E4%B8%AAcommit%2F</url>
    <content type="text"><![CDATA[回退命令：$git reset --hard HEAD^ 回退到上个版本 $git reset --hard HEAD~3 回退三次提交 $git reset --hard commit-id 退到/进到指定commit强推到远程：$git push origin HEAD --force 相关链接]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>版本回滚</tag>
        <tag>commit</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 进程间通讯方式]]></title>
    <url>%2F2019%2F03%2F08%2FAndroid%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1、通过单向数据管道传递数据 管道(使用PipedWriter/ 创建PipedReader)是java.io包的一部分。也就是说，它们是一般的Java功能，而不是Android特定的。管道为同一进程内的两个线程提供了一种连接和建立单向数据通道的方法。生产者线程将数据写入管道，而使用者线程从管道读取数据。 2、共享内存通信 共享内存（使用编程中已知的内存区域作为堆）是在线程之间传递信息的常用方法。应用程序中的所有线程都可以访问进程中的相同地址空间。 3、实现消费者 - 生产者模式 BlockingQueue 线程信令是一种低级，高度可配置的机制，可以适应许多用例，但它也可能被认为是最容易出错的技术。因此，Java平台在线程信令机制上构建高级抽象，以解决线程之间的任意对象的单向切换。抽象通常被称为“解决生产者 - 消费者同步问题。”问题包括可能存在生成内容的线程（生产者线程）和消费内容的线程（消费者线程）的用例。生产者将消息传递给消费者进行处理。线程之间的中介是具有阻塞行为的队列，即java.util.concurrent.BlockingQueue。 4、消息队列 消息处理机制是Android平台的基础，API位于android.os包中，其中包含一组实现该功能的类Handler。 android.os.Looper与唯一的消费者线程关联的消息调度程序。 android.os.Handler消费者线程消息处理器，以及生产者线程将消息插入队列的接口。Looper可以有许多关联的处理程序，但它们都将消息插入到同一队列中。 android.os.MessageQueue要在消费者线程上处理的无限链接消息列表。每个Looper和Thread-最多只有一个MessageQueue。 android.os.Message要在使用者线程上执行的消息。 原文链接]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>进程通讯</tag>
        <tag>线程</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载机制之验证]]></title>
    <url>%2F2019%2F03%2F08%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B9%8B%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[原文链接：https://blog.csdn.net/ns_code/article/details/17881581 目的验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。 目标不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>类加载机制</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础(JAVA移位运算符)]]></title>
    <url>%2F2019%2F03%2F08%2FJAVA%E5%9F%BA%E7%A1%80(JAVA%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6)%2F</url>
    <content type="text"><![CDATA[移位运算符** 就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种：&lt;&lt;（左移）、&gt;&gt;（带符号右移）和&gt;&gt;&gt;（无符号右移）。 在移位运算时，byte、short和char类型移位后的结果会变成int类型，对于byte、short、char和int进行移位时，规定实际移动的次数是移动次数和32的余数，也就是移位33次和移位1次得到的结果相同。移动long型的数值时，规定实际移动的次数是移动次数和64的余数，也就是移动66次和移动2次得到的结果相同。 ###三种移位运算符的移动规则和使用如下所示： “&lt;&lt;” 运算规则：按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零。语法格式 ：需要移位的数字 &lt;&lt; 移位的次数 例如： 3 &lt;&lt; 2，则是将数字3左移2位 计算过程： 3 &lt;&lt; 2 首先把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011，然后把该数字高位（左侧）的两个零移出，其他的数字都朝左平移2位，最后在低位（右侧）的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100，则转换为十进制是12.数学意义： 在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。 “&gt;&gt;”运算规则：按二进制形式把所有的数字向右移动对应巍峨位数，低位移出（舍弃），高位的空位补符号位，即正数补零，负数补1.语法格式：需要移位的数字 &gt;&gt; 移位的次数 例如11 &gt;&gt; 2，则是将数字11右移2位 计算过程：11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 1011，然后把低位的最后两个数字移出，因为该数字是正数，所以在高位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 0010.转换为十进制是3.数学意义：右移一位相当于除2，右移n位相当于除以2的n次方。 &gt;&gt;&gt;运算规则：按二进制形式把所有的数字向右移动对应巍峨位数，低位移出（舍弃），高位的空位补零。对于正数来说和带符号右移相同，对于负数来说不同。 其他结构和&gt;&gt;相似。 ###小结： 二进制运算符，包括位运算符和移位运算符，使程序员可以在二进制基础上操作数字，可以更有效的进行运算，并且可以以二进制的形式存储和转换数据，是实现网络协议解析以及加密等算法的基础。 实例操作： 12345678910111213141516171819202122232425262728public class test &#123; public static void main(String[] args) &#123; int i = -1; i &gt;&gt;&gt;= 10; System.out.println(i); mTest(); &#125;public static void mTest() &#123; //左移 int i = 12; //二进制为:0000000000000000000000000001100 i &lt;&lt;= 2; //i左移2位，把高位的两位数字(左侧开始)抛弃,低位的空位补0,二进制码就为0000000000000000000000000110000 System.out.println(i); //二进制110000值为48； System.out.println(&quot;&lt;br&gt;&quot;); //右移 i &gt;&gt;= 2; //i右移2为，把低位的两个数字(右侧开始)抛弃,高位整数补0，负数补1，二进制码就为0000000000000000000000000001100 System.out.println(i); //二进制码为1100值为12 System.out.println(&quot;&lt;br&gt;&quot;); //右移example int j = 11;//二进制码为00000000000000000000000000001011 j &gt;&gt;= 2; //右移两位，抛弃最后两位,整数补0,二进制码为：00000000000000000000000000000010 System.out.println(j); //二进制码为10值为2 System.out.println(&quot;&lt;br&gt;&quot;); byte k = -2; //转为int,二进制码为：0000000000000000000000000000010 k &gt;&gt;= 2; //右移2位，抛弃最后2位，负数补1,二进制吗为：11000000000000000000000000000 System.out.println(j); //二进制吗为11值为2 &#125;&#125; 在Thinking in Java第三章中的一段话: 移位运算符面向的运算对象也是 二进制的“位”。 可单独用它们处理整数类型（主类型的一种）。左移位运算符（&lt;&lt;）能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补0）。 “有符号”右移位运算符（&gt;&gt;）则将运算符左边的运算对象向右移动运算符右侧指定的位数。“有符号”右移位运算符使用了“符号扩展”：若值为正，则在高位插入0；若值为负，则在高位插入1。Java也添加了一种“无符号”右移位运算符（&gt;&gt;&gt;），它使用了“零扩展”：无论正负，都在高位插入0。这一运算符是C或C++没有的。 若对char，byte或者short进行移位处理，那么在移位进行之前，它们会自动转换成一个int。只有右侧的5个低位才会用到。这样可防止我们在一个int数里移动不切实际的位数。若对一个long值进行处理，最后得到的结果也 是long。此时只会用到右侧的6个低位，防止移动超过long值里现成的位数。但在进行“无符号”右移位时，也可能遇到一个问题。若对byte或 short值进行右移位运算，得到的可能不是正确的结果（Java 1.0和Java 1.1特别突出）。它们会自动转换成int类型，并进行右移位。但“零扩展”不会发生，所以在那些情况下会得到-1的结果。]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存回收机制]]></title>
    <url>%2F2019%2F03%2F08%2FJVM%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、回收算法 标记回收算法（Mark and Sweep GC)从GC Roots集合开始，将内存整个遍历一次，保留所有可以被GC Roots直接或间接引用到的对象，而剩下的对象都当作垃圾对待并回收，这个算法需要中断进程内其它组件的执行并且可能产生内存碎片 复制算法 (Copying）将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。 标记-压缩算法 (Mark-Compact)先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。 分代将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年代的内存空间。对于新生代适用于复制算法，而对于老年代则采取标记-压缩算法。 2、复制算法和标记-压缩算法的区别乍一看这两个算法似乎并没有多大的区别，都是标记了然后挪到另外的内存地址进行回收，那为什么不同的分代要使用不同的回收算法呢？ 其实2者最大的区别在于前者是用空间换时间后者则是用时间换空间。 前者的在工作的时候是不没有独立的mark与copy段的，而是合在一起做一个动作，就叫scavenge（或evacuate，或者就叫copy）。也就是说，每发现一个这次收集中尚未访问过的活对象就直接copy到新地方，同时设置forwarding pointer。这样的工作方式就需要多一份空间。 后者在工作的时候则需要分别的mark与compact阶段，mark阶段用来发现并标记所有活的对象，然后compact阶段才移动对象来达到compact的目的。如果compact方式是sliding compaction，则在mark之后就可以按顺序一个个对象滑动到空间的某一侧。因为已经先遍历了整个空间里的对象图，知道所有的活对象了，所以移动的时候就可以在同一个空间内而不需要多一份空间。 所以新生代的回收会更快一点，老年代的回收则会需要更长时间，同时压缩阶段是会暂停应用的，所以给我们应该尽量避免对象出现在老年代。]]></content>
      <categories>
        <category>Java</category>
        <category>GC</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>垃圾回收</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 二分查找算法]]></title>
    <url>%2F2019%2F03%2F08%2FJava%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、二分查找又称折半查找，它是一种效率较高的查找方法。2、二分查找要求： *（1）必须采用顺序存储结构 * （2）必须按关键字大小有序排列 3、原理：将数组分为三部分，依次是中值（所谓的中值就是数组中间位置的那个值）前，中值，中值后；将要查找的值和数组的中值进行比较，若小于中值则在中值前 面找，若大于中值则在中值后面找，等于中值时直接返回。然后依次是一个递归过程，将前半部分或者后半部分继续分解为三部分。 4、实现：二分查找的实现用递归和循环两种方式5、代码123456789101112131415161718192021222324252627282930313233343536373839404142package other;public class BinarySearch &#123; /* * 循环实现二分查找算法arr 已排好序的数组x 需要查找的数-1 无法查到数据 */ public static int binarySearch(int[] arr, int x) &#123; int low = 0; int high = arr.length-1; while(low &lt;= high) &#123; int middle = (low + high)/2; if(x == arr[middle]) &#123; return middle; &#125;else if(x &lt;arr[middle]) &#123; high = middle - 1; &#125;else &#123; low = middle + 1; &#125; &#125; return -1; &#125; //递归实现二分查找 public static int binarySearch(int[] dataset,int data,int beginIndex,int endIndex)&#123; int midIndex = (beginIndex+endIndex)/2; if(data &lt;dataset[beginIndex]||data&gt;dataset[endIndex]||beginIndex&gt;endIndex)&#123; return -1; &#125; if(data &lt;dataset[midIndex])&#123; return binarySearch(dataset,data,beginIndex,midIndex-1); &#125;else if(data&gt;dataset[midIndex])&#123; return binarySearch(dataset,data,midIndex+1,endIndex); &#125;else &#123; return midIndex; &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 6, 12, 33, 87, 90, 97, 108, 561 &#125;; System.out.println(&quot;循环查找：&quot; + (binarySearch(arr, 87) + 1)); System.out.println(&quot;递归查找&quot;+binarySearch(arr,87,2,arr.length-1)); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
